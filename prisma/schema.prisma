generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  PROCTOR
  REVIEWER
  CANDIDATE
}

enum ExamSessionStatus {
  SCHEDULED
  READY
  IN_PROGRESS
  PAUSED
  COMPLETED
  CANCELLED
  FLAGGED
  ABANDONED
}

enum RecordingType {
  WEBCAM
  SCREEN
  AUDIO
  MANIFEST
}

enum MediaChunkStatus {
  PENDING
  UPLOADING
  UPLOADED
  PROCESSING
  PROCESSED
  FAILED
}

enum FlagEventType {
  IDENTITY_MISMATCH
  MULTIPLE_PEOPLE
  NO_FACE_DETECTED
  SUSPICIOUS_AUDIO
  SCREEN_SWITCH
  BROWSER_ACTIVITY
  NETWORK_INSTABILITY
  OTHER
}

enum ConsentType {
  TERMS_OF_USE
  PRIVACY_POLICY
  RECORDING_NOTICE
  DATA_SHARING
}

enum IdImageType {
  DOCUMENT_FRONT
  DOCUMENT_BACK
  SELFIE
  OTHER
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  role          UserRole  @default(CANDIDATE)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts          Account[]
  sessions          Session[]
  consents          Consent[]
  auditLogs         AuditLog[]    @relation("AuditActor")
  candidateSessions ExamSession[] @relation("CandidateUser")
  proctoredSessions ExamSession[] @relation("ProctorUser")
}

model Account {
  id                 String  @id @default(cuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String? @db.Text
  access_token       String? @db.Text
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String? @db.Text
  session_state      String?
  oauth_token_secret String?
  oauth_token        String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  ipAddress    String?
  userAgent    String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime
  createdAt  DateTime @default(now())

  @@unique([identifier, token])
}

model Exam {
  id              String   @id @default(cuid())
  title           String
  description     String?
  durationMinutes Int
  requirements    String?  @db.Text
  retentionDays   Int      @default(365)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  sessions  ExamSession[]
  auditLogs AuditLog[]
}

model ExamSession {
  id                  String            @id @default(cuid())
  examId              String
  candidateId         String?
  proctorId           String?
  status              ExamSessionStatus @default(SCHEDULED)
  scheduledStart      DateTime?
  startedAt           DateTime?
  submittedAt         DateTime?
  completedAt         DateTime?
  cancelledAt         DateTime?
  flaggedAt           DateTime?
  candidateName       String?
  candidateEmail      String?
  candidateExternalId String?
  candidatePhone      String?
  timezone            String?
  notes               String?           @db.Text
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  exam       Exam        @relation(fields: [examId], references: [id], onDelete: Cascade)
  candidate  User?       @relation("CandidateUser", fields: [candidateId], references: [id], onDelete: SetNull)
  proctor    User?       @relation("ProctorUser", fields: [proctorId], references: [id], onDelete: SetNull)
  recordings Recording[]
  flagEvents FlagEvent[]
  consents   Consent[]
  idImages   IdImage[]
  auditLogs  AuditLog[]

  @@index([examId, status], name: "ExamSession_examId_status_idx")
  @@index([candidateEmail], name: "ExamSession_candidateEmail_idx")
}

model Recording {
  id          String        @id @default(cuid())
  sessionId   String
  type        RecordingType
  s3Key       String
  uri         String?
  durationMs  Int?
  sizeBytes   BigInt?
  startedAt   DateTime?
  completedAt DateTime?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  session    ExamSession  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  chunks     MediaChunk[]
  flagEvents FlagEvent[]

  @@index([sessionId, type], name: "Recording_session_type_idx")
}

model MediaChunk {
  id            String           @id @default(cuid())
  recordingId   String
  index         Int
  status        MediaChunkStatus @default(PENDING)
  byteSize      Int?
  checksum      String?
  uploadedAt    DateTime?
  processedAt   DateTime?
  failureReason String?          @db.Text
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  recording  Recording   @relation(fields: [recordingId], references: [id], onDelete: Cascade)
  flagEvents FlagEvent[]

  @@unique([recordingId, index], map: "MediaChunk_recording_index_key")
  @@index([recordingId, status], name: "MediaChunk_recording_status_idx")
}

model FlagEvent {
  id           String        @id @default(cuid())
  sessionId    String
  recordingId  String?
  mediaChunkId String?
  type         FlagEventType
  confidence   Float?
  message      String?       @db.Text
  metadata     Json?
  createdAt    DateTime      @default(now())

  session    ExamSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  recording  Recording?  @relation(fields: [recordingId], references: [id], onDelete: SetNull)
  mediaChunk MediaChunk? @relation(fields: [mediaChunkId], references: [id], onDelete: SetNull)

  @@index([sessionId, createdAt], name: "FlagEvent_session_createdAt_idx")
}

model Consent {
  id         String      @id @default(cuid())
  sessionId  String
  userId     String?
  type       ConsentType
  accepted   Boolean     @default(false)
  acceptedAt DateTime?
  ipAddress  String?
  userAgent  String?
  metadata   Json?
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt

  session ExamSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user    User?       @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@unique([sessionId, type], map: "Consent_session_type_key")
}

model IdImage {
  id          String      @id @default(cuid())
  sessionId   String
  type        IdImageType
  s3Key       String
  blurHash    String?
  capturedAt  DateTime
  processedAt DateTime?
  metadata    Json?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  session ExamSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@unique([sessionId, type], map: "IdImage_session_type_key")
  @@index([sessionId, capturedAt], name: "IdImage_session_capturedAt_idx")
}

model AuditLog {
  id          String   @id @default(cuid())
  actorId     String?
  examId      String?
  sessionId   String?
  targetType  String
  targetId    String?
  action      String
  description String?  @db.Text
  metadata    Json?
  createdAt   DateTime @default(now())

  actor   User?        @relation("AuditActor", fields: [actorId], references: [id], onDelete: SetNull)
  exam    Exam?        @relation(fields: [examId], references: [id], onDelete: SetNull)
  session ExamSession? @relation(fields: [sessionId], references: [id], onDelete: SetNull)

  @@index([targetType, targetId], name: "AuditLog_target_idx")
  @@index([createdAt], name: "AuditLog_createdAt_idx")
}
